{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"About this Blog This blog will probably mostly contain posts about DevOps, programming, Linux, neat opensource projects, and similar topics. It will probably be updated sporadically and infrequently. About Me My name is William Lieberz. I was born and raised in Los Angeles. I am currently working as a Senior Systems Engineer in the Container Engineering space*. *Currently, for me, the Container Engineering space consists of: Container registries/repos, writing and maintaining common library Helm charts, etc., as well as creating automation and tooling around these topics to promote best-practices and add governance guardrails for our dev teams. LinkedIn LinkedIn GitHub GitHub Technical things I enjoy DevOps culture: The Phoenix Project The Unicorn Project The Idealcast podcast Agile Manifesto DevOps tooling: Kubernetes Docker Terraform Helm CI/CD Pipelines Ansible Programming Languages: Rust Linux Distros: Server: Alpine Flatcar Debian Desktop: Kubuntu OpenSUSE Leap Tumbleweed Desktop Environments: KDE Non-technical things I enjoy Walking and talking with my amazing wife Playing bass guitar, poorly :-) Playing electric guitar, also poorly :-) Watching movies - some recent-ish good movies: Elvis Chip 'n Dale: Rescue Rangers Black Phone The Unbearable Weight of Massive Talent Everything Everywhere, All At Once Watching tv shows - very non-exhaustive sample list: Severance Westworld The Orville Blackbird Killing Eve Dexter Playing video games - some favorites: Every 3D Legend of Zelda game Half-Life 2 Listening to music Favorites for all occasions: The Greatest Song of All Time The Second Greatest Song of All Time The Third Greatest Song of All Time Favorites for programming: Forest Interlude from Donkey Kong Country 2 Inside the Deku Tree theme from The Legend of Zelda: Ocarina of Time Stray (videogame soundtrack)","title":"Home"},{"location":"#about-this-blog","text":"This blog will probably mostly contain posts about DevOps, programming, Linux, neat opensource projects, and similar topics. It will probably be updated sporadically and infrequently.","title":"About this Blog"},{"location":"#about-me","text":"My name is William Lieberz. I was born and raised in Los Angeles. I am currently working as a Senior Systems Engineer in the Container Engineering space*. *Currently, for me, the Container Engineering space consists of: Container registries/repos, writing and maintaining common library Helm charts, etc., as well as creating automation and tooling around these topics to promote best-practices and add governance guardrails for our dev teams.","title":"About Me"},{"location":"#linkedin","text":"LinkedIn","title":"LinkedIn"},{"location":"#github","text":"GitHub","title":"GitHub"},{"location":"#technical-things-i-enjoy","text":"DevOps culture: The Phoenix Project The Unicorn Project The Idealcast podcast Agile Manifesto DevOps tooling: Kubernetes Docker Terraform Helm CI/CD Pipelines Ansible Programming Languages: Rust Linux Distros: Server: Alpine Flatcar Debian Desktop: Kubuntu OpenSUSE Leap Tumbleweed Desktop Environments: KDE","title":"Technical things I enjoy"},{"location":"#non-technical-things-i-enjoy","text":"Walking and talking with my amazing wife Playing bass guitar, poorly :-) Playing electric guitar, also poorly :-) Watching movies - some recent-ish good movies: Elvis Chip 'n Dale: Rescue Rangers Black Phone The Unbearable Weight of Massive Talent Everything Everywhere, All At Once Watching tv shows - very non-exhaustive sample list: Severance Westworld The Orville Blackbird Killing Eve Dexter Playing video games - some favorites: Every 3D Legend of Zelda game Half-Life 2 Listening to music Favorites for all occasions: The Greatest Song of All Time The Second Greatest Song of All Time The Third Greatest Song of All Time Favorites for programming: Forest Interlude from Donkey Kong Country 2 Inside the Deku Tree theme from The Legend of Zelda: Ocarina of Time Stray (videogame soundtrack)","title":"Non-technical things I enjoy"},{"location":"2021-02-14-sudo-vulnerability-CVE-2021-3156/","text":"CVE-2021-3156 \"Baron Samedit\" sudo vulnerability - checking hosts Date: 2021-02-14 Categories: sudo, CVE-2021-3156, Baron Samedit, security, linux, Ansible Background Hopefully you are already certain all Linux systems you maintain have been patched to remediate the recent nasty sudo vulnerability , but sometimes it is nice to do yet another sweep through the environment to verify there are no lingering unpatched hosts. I wrote a quick Ansible playbook to check if a host is vulnerable or patched. Ansible Playbook Usage You can run the playbook like this: anisble-playbook -K -i test-inventory check-sudo-vuln-CVE-2021-3156.yml -e target=testing The -K is to \"Prompt for the password to use with sudo, if any\", if you have passwordless sudo for your account on your remote servers, you can omit this flag. The -i is to allow you to point to a particular Anisble inventory file. I'm using one called \"test-inventory\" for purposes of...testing. The -e is to pass an extra variable where we define the variable \"target\" as being equal to \"testing\". The \"testing\" target is a host group defined in the inventory file. The simple test-inventory file looks like this: [testing] host01 host02 Ansible Playbook Output Running the playbook will produce output similar to: TASK [Show Vulnerable Hosts] ******************************** skipping: [host01] ok: [host02] => { \"msg\": \"VULNERABLE: host02\" } Any host which is patched will be skipped by the \"Show Vulnerable Hosts\" task. Any vulnerable host will be logged with the message \"VULNERABLE: $hostName\". It would be nicer if there was a way to get the output of vulnerable hosts to not show \"ok\" but I have not found a good way to change that in Ansible. Basically, the task to \"show vulnerable hosts\" succeeded, so that is why we see \"ok\" in the playbook output. As a workaround, I tried setting the task to always fail and ignore errors (so execution of the playbook doesn't stop), which flags the entire task as red, but the output is more cluttered with debug information so I opted not to use that method. Hopefully this is helpful to someone!","title":"CVE-2021-3156 \"Baron Samedit\" - checking hosts"},{"location":"2021-02-14-sudo-vulnerability-CVE-2021-3156/#cve-2021-3156-baron-samedit-sudo-vulnerability-checking-hosts","text":"Date: 2021-02-14 Categories: sudo, CVE-2021-3156, Baron Samedit, security, linux, Ansible","title":"CVE-2021-3156 \"Baron Samedit\" sudo vulnerability - checking hosts"},{"location":"2021-02-14-sudo-vulnerability-CVE-2021-3156/#background","text":"Hopefully you are already certain all Linux systems you maintain have been patched to remediate the recent nasty sudo vulnerability , but sometimes it is nice to do yet another sweep through the environment to verify there are no lingering unpatched hosts. I wrote a quick Ansible playbook to check if a host is vulnerable or patched.","title":"Background"},{"location":"2021-02-14-sudo-vulnerability-CVE-2021-3156/#ansible-playbook-usage","text":"You can run the playbook like this: anisble-playbook -K -i test-inventory check-sudo-vuln-CVE-2021-3156.yml -e target=testing The -K is to \"Prompt for the password to use with sudo, if any\", if you have passwordless sudo for your account on your remote servers, you can omit this flag. The -i is to allow you to point to a particular Anisble inventory file. I'm using one called \"test-inventory\" for purposes of...testing. The -e is to pass an extra variable where we define the variable \"target\" as being equal to \"testing\". The \"testing\" target is a host group defined in the inventory file. The simple test-inventory file looks like this: [testing] host01 host02","title":"Ansible Playbook Usage"},{"location":"2021-02-14-sudo-vulnerability-CVE-2021-3156/#ansible-playbook-output","text":"Running the playbook will produce output similar to: TASK [Show Vulnerable Hosts] ******************************** skipping: [host01] ok: [host02] => { \"msg\": \"VULNERABLE: host02\" } Any host which is patched will be skipped by the \"Show Vulnerable Hosts\" task. Any vulnerable host will be logged with the message \"VULNERABLE: $hostName\". It would be nicer if there was a way to get the output of vulnerable hosts to not show \"ok\" but I have not found a good way to change that in Ansible. Basically, the task to \"show vulnerable hosts\" succeeded, so that is why we see \"ok\" in the playbook output. As a workaround, I tried setting the task to always fail and ignore errors (so execution of the playbook doesn't stop), which flags the entire task as red, but the output is more cluttered with debug information so I opted not to use that method. Hopefully this is helpful to someone!","title":"Ansible Playbook Output"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/","text":"CVE-2021-3156 \"Baron Samedit\" - patching RHEL-7 & RHEL-5 hosts Date: 2021-02-15 Categories: sudo, CVE-2021-3156, Baron Samedit, security, linux, Ansible Background Yesterday, I posted a simple Ansible playbook to automate the verification of the patch status of hosts against the sudo vulnerability CVE-2021-3156 . In case anyone finds it helpful, I'm sharing my playbook for patching RHEL-5 and RHEL-7 hosts. In an ideal world there would be no more RHEL-5 hosts since even the Extended Life Cycle Support for RHEL-5 ended on November 30, 2020. However, I think we can agreee that we don't live in an ideal world, unfortunately. Playbook Usage Assumptions The playbook assumes that RHEL-7 hosts can reach thier repos normally, but that the RHEL-5 hosts are on a restricted vlan without internet access, and also that the Ansible control host can reach the internet to fetch packages and push said packages to the RHEL-5 hosts. Actions Running the playbook will download the RHEL-5 32-bit & 64-bit rpm packages and PGP keys from the sudo-project to the Ansible host. This is idempotent, so you only need to fetch the files once. Note: you should add a line like *.rpm to your .gitignore to avoid checking rpm packages into git. Next, we have two blocks, each with a when: conditional. The first block executes when the OS is RHEL-7, based on Ansible facts and simply uses the yum module to ensure the sudo package is at the latest version. The second block similarly only runs when the host is RHEL-5. It copies the appropriate RPM (based on the system architecture) to the remote host along with the PGP keys. Next, it imports the pgp keys, then does a local install of the sudo rpm, and finally removes all temp files which were copied over. If you had the need to patch RHEL-6 hosts, the playbook could be easily extended with a similar pattern.","title":"CVE-2021-3156 \"Baron Samedit\" - patching RHEL-7 & RHEL-5 hosts"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/#cve-2021-3156-baron-samedit-patching-rhel-7-rhel-5-hosts","text":"Date: 2021-02-15 Categories: sudo, CVE-2021-3156, Baron Samedit, security, linux, Ansible","title":"CVE-2021-3156 \"Baron Samedit\" - patching RHEL-7 &amp; RHEL-5 hosts"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/#background","text":"Yesterday, I posted a simple Ansible playbook to automate the verification of the patch status of hosts against the sudo vulnerability CVE-2021-3156 . In case anyone finds it helpful, I'm sharing my playbook for patching RHEL-5 and RHEL-7 hosts. In an ideal world there would be no more RHEL-5 hosts since even the Extended Life Cycle Support for RHEL-5 ended on November 30, 2020. However, I think we can agreee that we don't live in an ideal world, unfortunately.","title":"Background"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/#playbook-usage","text":"","title":"Playbook Usage"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/#assumptions","text":"The playbook assumes that RHEL-7 hosts can reach thier repos normally, but that the RHEL-5 hosts are on a restricted vlan without internet access, and also that the Ansible control host can reach the internet to fetch packages and push said packages to the RHEL-5 hosts.","title":"Assumptions"},{"location":"2021-02-15-sudo-vulnerability-CVE-2021-3156-rhel5-patching/#actions","text":"Running the playbook will download the RHEL-5 32-bit & 64-bit rpm packages and PGP keys from the sudo-project to the Ansible host. This is idempotent, so you only need to fetch the files once. Note: you should add a line like *.rpm to your .gitignore to avoid checking rpm packages into git. Next, we have two blocks, each with a when: conditional. The first block executes when the OS is RHEL-7, based on Ansible facts and simply uses the yum module to ensure the sudo package is at the latest version. The second block similarly only runs when the host is RHEL-5. It copies the appropriate RPM (based on the system architecture) to the remote host along with the PGP keys. Next, it imports the pgp keys, then does a local install of the sudo rpm, and finally removes all temp files which were copied over. If you had the need to patch RHEL-6 hosts, the playbook could be easily extended with a similar pattern.","title":"Actions"},{"location":"2021-02-21-Install-Bitwarden-appimage-on-KDE-distro/","text":"Installing Bitwarden via AppImage on a KDE Distro Date: 2021-02-21 Categories: linux, security, appimage, kde, bitwarden Background I've been wanting to try the password manager Bitwarden for some time now, and the recently announced changes to the free edition of LastPass was just the push I needed to give Bitwarden an earnest try. I can report that the process of exporting my data from the LastPass browser extension to csv, then importing it into Bitwarden was easy and painless. While the steps were self-explanatory, I do appreciate that Bitwarden has a reference document for the process. I exported from the LastPass browser extension and imported into the Bitwarden web interface. I really appreciate that while Bitwarden provides the usual iOS, Android, Windows, and macOS binaries, they also provide a cross-distro compatible Linux package in the form of an AppImage . While the Snap vs Flatpak debate seems to get the most attention, it is nice to see AppImage getting some love. Installation Disclaimer: this is not the only way to handle installation, and may not be the best method, depending on your needs, but this is how I like to do it. This method installs into your home directory, so we assume that no other users on your system will need access to Bitwarden. Of course, it would be trivial to modify these steps slightly to install to some centrally accessible location like /usr/local/bin provided that you have sudo rights on the machine. # Create a bin directory in your home: mkdir ~/bin cd ~/bin # Get the latest available AppImage Bitwarden package: wget \"https://vault.bitwarden.com/download/?app=desktop&platform=linux\" # Make the AppImage executable: chmod 775 Bitwarden*.AppImage # Since the Bitwarden AppImage binary will change its name whenever it # it auto-updates, I like to create a wrapper-script to call it: cat << EOF > ./bitwarden.sh #!/usr/bin/env bash $HOME/bin/Bitwarden*.AppImage EOF chmod 770 bitwarden.sh Integrating with KDE menu Next, I like to integrate the application into my KDE menu. This should work regardless of the underlying distro, as long as your desktop environment is KDE (and why wouldn't it be?). Right-click on the KDE menu, click \"New Item\", type the name \"Bitwarden\", and click \"ok\". On the left hand side, drag the Bitwarden menu item into the category that makes the most sense to you - I usually put it in the \"Office\" category. On the right-hand side: Optionally add a description and comment, but definitely modify the \"Command\" field to point to the path where you put the AppImage. Hint: use the wrapper script you created earlier: ~/bin/bitwarden.sh . You can also add an icon by clicking the empty square in the KDE Menu Editor (right-hand side). Usually I search within system icons for \"lock\" and just use a generic padlock icon. When done, click \"save\" to close out of the Menu Editor. I have heard there is an AppImage daemon appimaged as well as a Launcher project AppImageLauncher , either of which would probably help with the automation of integrating AppImage apps into GUI menus, and also might add some automation around updating the AppImages themselves. I should probably look into these if I start using AppImages on a larger scale. If I do, I'll try to come back and edit this post. It doesn't much matter where you put the AppImage and whether or not you integrate it into the menu of your desktop environment of choice. As far as I can tell, Bitwarden will store local data in your home directory, as a well-behaved desktop application should, in ~/.config/Bitwarden . Finally, just a friendly reminder to ensure you have configured two factor authentication . Happy password managing!","title":"Installing Bitwarden via AppImage on a KDE Distro"},{"location":"2021-02-21-Install-Bitwarden-appimage-on-KDE-distro/#installing-bitwarden-via-appimage-on-a-kde-distro","text":"Date: 2021-02-21 Categories: linux, security, appimage, kde, bitwarden","title":"Installing Bitwarden via AppImage on a KDE Distro"},{"location":"2021-02-21-Install-Bitwarden-appimage-on-KDE-distro/#background","text":"I've been wanting to try the password manager Bitwarden for some time now, and the recently announced changes to the free edition of LastPass was just the push I needed to give Bitwarden an earnest try. I can report that the process of exporting my data from the LastPass browser extension to csv, then importing it into Bitwarden was easy and painless. While the steps were self-explanatory, I do appreciate that Bitwarden has a reference document for the process. I exported from the LastPass browser extension and imported into the Bitwarden web interface. I really appreciate that while Bitwarden provides the usual iOS, Android, Windows, and macOS binaries, they also provide a cross-distro compatible Linux package in the form of an AppImage . While the Snap vs Flatpak debate seems to get the most attention, it is nice to see AppImage getting some love.","title":"Background"},{"location":"2021-02-21-Install-Bitwarden-appimage-on-KDE-distro/#installation","text":"Disclaimer: this is not the only way to handle installation, and may not be the best method, depending on your needs, but this is how I like to do it. This method installs into your home directory, so we assume that no other users on your system will need access to Bitwarden. Of course, it would be trivial to modify these steps slightly to install to some centrally accessible location like /usr/local/bin provided that you have sudo rights on the machine. # Create a bin directory in your home: mkdir ~/bin cd ~/bin # Get the latest available AppImage Bitwarden package: wget \"https://vault.bitwarden.com/download/?app=desktop&platform=linux\" # Make the AppImage executable: chmod 775 Bitwarden*.AppImage # Since the Bitwarden AppImage binary will change its name whenever it # it auto-updates, I like to create a wrapper-script to call it: cat << EOF > ./bitwarden.sh #!/usr/bin/env bash $HOME/bin/Bitwarden*.AppImage EOF chmod 770 bitwarden.sh","title":"Installation"},{"location":"2021-02-21-Install-Bitwarden-appimage-on-KDE-distro/#integrating-with-kde-menu","text":"Next, I like to integrate the application into my KDE menu. This should work regardless of the underlying distro, as long as your desktop environment is KDE (and why wouldn't it be?). Right-click on the KDE menu, click \"New Item\", type the name \"Bitwarden\", and click \"ok\". On the left hand side, drag the Bitwarden menu item into the category that makes the most sense to you - I usually put it in the \"Office\" category. On the right-hand side: Optionally add a description and comment, but definitely modify the \"Command\" field to point to the path where you put the AppImage. Hint: use the wrapper script you created earlier: ~/bin/bitwarden.sh . You can also add an icon by clicking the empty square in the KDE Menu Editor (right-hand side). Usually I search within system icons for \"lock\" and just use a generic padlock icon. When done, click \"save\" to close out of the Menu Editor. I have heard there is an AppImage daemon appimaged as well as a Launcher project AppImageLauncher , either of which would probably help with the automation of integrating AppImage apps into GUI menus, and also might add some automation around updating the AppImages themselves. I should probably look into these if I start using AppImages on a larger scale. If I do, I'll try to come back and edit this post. It doesn't much matter where you put the AppImage and whether or not you integrate it into the menu of your desktop environment of choice. As far as I can tell, Bitwarden will store local data in your home directory, as a well-behaved desktop application should, in ~/.config/Bitwarden . Finally, just a friendly reminder to ensure you have configured two factor authentication . Happy password managing!","title":"Integrating with KDE menu"},{"location":"Rust-Learning-Resources/","text":"Rust Learning Resources Date: 2022-10-05 Categories: rust, learning About The intention of this blog post is to serve as a quick cheatsheet for those who may be interested in learning Rust, whether for the first time or to take existing skills to the next level. I am by no means a Rust expert, but I've found these resources helpful and I hope some of them will help you too! As I come across new resources, I'll be sure to update this page. The Rust Book (official) The first place you should start is the official docs - they are fantastic! Particularly, I think the The Rust Book should be everybody's first stop. It is official, and it is entirely free. I've read it cover-to-cover and re-read certain sections. I love that the example programs in the book are simple enough to easily understand, but still complex enough to seem like they are modeling a real-world problem that is worth solving. Rust By Example (official) If you come from another compiled language or you enjoy more to-the-point and terse examples, you may enjoy Rust By Example . It is also an excellent resource after you have read The Rust Book and just need a quick review of a specific topic. The Rust Book and Rust By Example are not the only official Rust learning resources. More can be found here: https://www.rust-lang.org/learn . No Boilerplate (youtube) The No Boilerplate YouTube channel has some interesting lightning talks about various Rust topics. You won't be learning any topics in-depth in the seven to twelve minute videos, but they often offer an interesting angle on a topic. Additionally, the videos might serve as a nice bit of motivation to continue your Rust studies, as you get glimpses of things that are possible in Rust, and some of Rust's unique value propositions. If you only watch one video, watch: Rust: Your code can be PERFECT Sure, the title has a strong whiff of clickbait and the video has more than a strong taste of Rust Kool-Aid, but, in my mind, the point is still valid: with Rust, once your code compiles, you'll likely spend more time implementing new features and fixing logical bugs, than fixing bugs arising from safety issues or stability issues. Cliffle (blog) There are some really excellent Rust posts on https://cliffle.com/blog . Some posts of note: The Typestate Pattern in Rust Highly recommended reading. The Typestate Pattern is not unique to Rust, but Rust's language design lends itself very well to this powerful pattern. Why Rust mutexes look like they do I love this type of article. It is in the format where a common complaint is explored and, in good faith, the author attempts to address the complaint. In this case, the author explores an alternate mutex implementation in Rust with the goal of it being more like a C/C++ mutex. As we go on this journey with the author, we find several major problems. In order to solve those problems, we find that the only viable solution ends up looking almost exactly like the Rust standard library mutex implementation. A great reason to read this article is that you might learn something about C and C++, mutexes, and software engineering in general. Prefer Rust to C/C++ for new code If you are looking for an article to help convince your boss (or yourself) to take the plunge and invest the time and effort to switch to Rust, this article might be for you. As an added bonus, this article is extremely pragmatic and does not blindly recommend Rust - it includes an excellent \"When to not use Rust\" section as well. Faster Than Lime (blog) Amos, over at https://fasterthanli.me/ writes intensely technical, excellent, and almost-always Rust-centric posts. The blog features Cool Bear, a cartoon bear who pops into the margins to ask insightful questions and sometimes poke and prod Amos into re-writing a solution in a more elegant way. Cool Bear is very cool. Some posts of note: I want off Mr. Golang's Wild Ride An infamous post, with an appeal to choose Rust over Go. Although it may have started flame-wars, the post is very sincere and his argument is very carefully laid out. Very strongly recommended reading. Lies we tell ourselves to keep using Golang A sequel to I want off Mr. Golang's Wild Ride . If you made it through the original, you will definitely want to read this one. Advent of Code 2020 All the posts in the Advent of Code series offer some great insights into solving various problems with Rust. It is interesting to see which crates he selected for the various problems. I recommend starting at Day 1 and working your way forward. Learn Rust With Entirely Too Many Linked Lists (unofficial) Learn Rust With Entirely Too Many Linked Lists I've not read through the entire book, but it seems promising. I would probably not recommend this as your first foray into Rust-land - The Rust Book is a much kinder, gentler, and probably more useful introduction. One of the common arguments against using Rust goes something like: \"It is impossible to implement a linked list in (safe) Rust, so you shouldn't use Rust\". The book offers a very thorough exploration of this topic. As advertised, it definitely involves too many linked lists.","title":"Rust Learning Resources"},{"location":"Rust-Learning-Resources/#rust-learning-resources","text":"Date: 2022-10-05 Categories: rust, learning","title":"Rust Learning Resources"},{"location":"Rust-Learning-Resources/#about","text":"The intention of this blog post is to serve as a quick cheatsheet for those who may be interested in learning Rust, whether for the first time or to take existing skills to the next level. I am by no means a Rust expert, but I've found these resources helpful and I hope some of them will help you too! As I come across new resources, I'll be sure to update this page.","title":"About"},{"location":"Rust-Learning-Resources/#the-rust-book-official","text":"The first place you should start is the official docs - they are fantastic! Particularly, I think the The Rust Book should be everybody's first stop. It is official, and it is entirely free. I've read it cover-to-cover and re-read certain sections. I love that the example programs in the book are simple enough to easily understand, but still complex enough to seem like they are modeling a real-world problem that is worth solving.","title":"The Rust Book (official)"},{"location":"Rust-Learning-Resources/#rust-by-example-official","text":"If you come from another compiled language or you enjoy more to-the-point and terse examples, you may enjoy Rust By Example . It is also an excellent resource after you have read The Rust Book and just need a quick review of a specific topic. The Rust Book and Rust By Example are not the only official Rust learning resources. More can be found here: https://www.rust-lang.org/learn .","title":"Rust By Example (official)"},{"location":"Rust-Learning-Resources/#no-boilerplate-youtube","text":"The No Boilerplate YouTube channel has some interesting lightning talks about various Rust topics. You won't be learning any topics in-depth in the seven to twelve minute videos, but they often offer an interesting angle on a topic. Additionally, the videos might serve as a nice bit of motivation to continue your Rust studies, as you get glimpses of things that are possible in Rust, and some of Rust's unique value propositions. If you only watch one video, watch: Rust: Your code can be PERFECT Sure, the title has a strong whiff of clickbait and the video has more than a strong taste of Rust Kool-Aid, but, in my mind, the point is still valid: with Rust, once your code compiles, you'll likely spend more time implementing new features and fixing logical bugs, than fixing bugs arising from safety issues or stability issues.","title":"No Boilerplate (youtube)"},{"location":"Rust-Learning-Resources/#cliffle-blog","text":"There are some really excellent Rust posts on https://cliffle.com/blog . Some posts of note: The Typestate Pattern in Rust Highly recommended reading. The Typestate Pattern is not unique to Rust, but Rust's language design lends itself very well to this powerful pattern. Why Rust mutexes look like they do I love this type of article. It is in the format where a common complaint is explored and, in good faith, the author attempts to address the complaint. In this case, the author explores an alternate mutex implementation in Rust with the goal of it being more like a C/C++ mutex. As we go on this journey with the author, we find several major problems. In order to solve those problems, we find that the only viable solution ends up looking almost exactly like the Rust standard library mutex implementation. A great reason to read this article is that you might learn something about C and C++, mutexes, and software engineering in general. Prefer Rust to C/C++ for new code If you are looking for an article to help convince your boss (or yourself) to take the plunge and invest the time and effort to switch to Rust, this article might be for you. As an added bonus, this article is extremely pragmatic and does not blindly recommend Rust - it includes an excellent \"When to not use Rust\" section as well.","title":"Cliffle (blog)"},{"location":"Rust-Learning-Resources/#faster-than-lime-blog","text":"Amos, over at https://fasterthanli.me/ writes intensely technical, excellent, and almost-always Rust-centric posts. The blog features Cool Bear, a cartoon bear who pops into the margins to ask insightful questions and sometimes poke and prod Amos into re-writing a solution in a more elegant way. Cool Bear is very cool. Some posts of note: I want off Mr. Golang's Wild Ride An infamous post, with an appeal to choose Rust over Go. Although it may have started flame-wars, the post is very sincere and his argument is very carefully laid out. Very strongly recommended reading. Lies we tell ourselves to keep using Golang A sequel to I want off Mr. Golang's Wild Ride . If you made it through the original, you will definitely want to read this one. Advent of Code 2020 All the posts in the Advent of Code series offer some great insights into solving various problems with Rust. It is interesting to see which crates he selected for the various problems. I recommend starting at Day 1 and working your way forward.","title":"Faster Than Lime (blog)"},{"location":"Rust-Learning-Resources/#learn-rust-with-entirely-too-many-linked-lists-unofficial","text":"Learn Rust With Entirely Too Many Linked Lists I've not read through the entire book, but it seems promising. I would probably not recommend this as your first foray into Rust-land - The Rust Book is a much kinder, gentler, and probably more useful introduction. One of the common arguments against using Rust goes something like: \"It is impossible to implement a linked list in (safe) Rust, so you shouldn't use Rust\". The book offers a very thorough exploration of this topic. As advertised, it definitely involves too many linked lists.","title":"Learn Rust With Entirely Too Many Linked Lists (unofficial)"}]}